load "iovtk"
include "getARGV.idp"

int m = getARGV("-m", 10); // setting number of samples
string weights = getARGV("-w", "");

real[int] w(m);

try{
    ifstream fw(weights);
    for(int i=0; i<m; i++) fw >> w[i];
} catch(...) {
    for(int i=0; i<m; i++) w[i] = 1./m;
}

mesh Th0 = readmesh("./storage/meshes/det/mesh0.msh"); // body
mesh Th1 = readmesh("./storage/meshes/det/mesh1.msh"); // inculsion 
mesh Th = readmesh("./storage/meshes/det/mesh.msh"); // initialising mesh

fespace Vh1(Th, P1);
Vh1 ESig, ESig2, VSig, sigi;

fespace Vh(Th, [P1,P1]);
Vh [Eu,Ev], [ui,vi];

for(int i=1; i<m+1; i++){
    ifstream fsigi("./storage/solutions/rand/sig/sig_" + i + ".txt");
    fsigi >> sigi[];

    ifstream fui("./storage/solutions/rand/u/u_" + i + ".txt");
    fui >> ui[];

    ifstream fvi("./storage/solutions/rand/v/v_" + i + ".txt");
    fvi >> vi[];

    ESig = ESig + w[i-1]*sigi;
    ESig2 = ESig2 + w[i-1]*sigi*sigi;
    [Eu,Ev] = [Eu,Ev] + [w[i-1]*ui,w[i-1]*vi];
}

VSig = ESig2 - ESig*ESig;

if(m>=8000){
    savevtk("./exp/sig_exp_10k.vtu", Th, ESig, dataname="sig_exp_10k");
    savevtk("./exp/sig_var_10k.vtu", Th, VSig, dataname="sig_var_10k");

    mesh Th0d = movemesh(Th0, [x+Eu, y+Ev]); 
    mesh Th1d = movemesh(Th1, [x+Eu, y+Ev]); 
    mesh Thd =Th0d + Th1d; // body deformation
}

if (m<=8) {
    savemesh(Th0, "./exp/mesh0.msh");
    savemesh(Th1, "./exp/mesh1.msh");
    savemesh(Th, "./exp/mesh.msh");
}

string feu = "./exp/u_exp_" + m + ".txt";;
string fev = "./exp/v_exp_" + m + ".txt";

ofstream ffeu(feu);
ofstream ffev(fev);

ffeu << Eu[];
ffev << Ev[];
