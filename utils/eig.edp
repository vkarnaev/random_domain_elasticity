load "msh3"

mesh Th = readmesh("./storage/meshes/det/mesh.msh"); // initialising mesh
int Nv = Th.nv; // number of vertices

/* KERNEL FUNCTION */

func real B(real x, real y){
  real R = 5*abs((sqrt(x^2+y^2) - 0.5))+1.5;
  return (0.5*R^2*((R>=0)&&(R<1)) + 0.5*(-2*R^2 + 6*R-3)*((R>=1)&&(R<2)) +  0.5*((3-R)^2)*((R>=2)&&(R<3)))*4/3;
}

func real K (real xi, real yi, real xj, real yj, int r, int s){ // Kernel function
  real c = 1./30;
  real bi = B(xi,yi);
  real bj = B(xj,yj);

  real thetai = atan2(yi,xi);
  real thetaj = atan2(yj,xj);

  real f = 0.;

    if (r==1){
      if (s==1) f = 5*exp(-8.*((xi-xj)^2 + (yi-yj)^2))*cos(thetai)*cos(thetaj);
      else f = -exp(-5.*((2*xi-xj)^2 + (2*yi-yj)^2))*cos(thetai)*sin(thetaj);
    } else {
      if (s==1) f = -exp(-5.*((xi-2*xj)^2 + (yi-2*yj)^2))*sin(thetai)*cos(thetaj);
      else f = 5*exp(-8.*((xi-xj)^2 + (yi-yj)^2))*sin(thetai)*sin(thetaj);
    }

    f *= bi*bj*c;
  return f;
}

/* PIVOTED CHOLESKY DECOMPOSTION */

real tl = 1e-10;
int stop = 102;

int k = 0;
int swtch = 0;
int pivot = 0;

int r = 0;
int s = 0;

real xi = 0.;
real yi = 0.;
real xk = 0.;
real yk = 0.;

real dk = 0.;
real tr = 0.0;

int[int] p(2*Nv);
real[int] D(2*Nv);

  for (int i = 0; i < 2*Nv; i++) {
    if(i< Nv){
      r = 1;
      xi = Th(i).x;
      yi = Th(i).y;
    } else {
      r = 2;
      xi = Th(i-Nv).x;
      yi = Th(i-Nv).y;
    }

    p(i) = i; // indeces
    D(i) = K(xi,yi,xi,yi,r,r); // diagonal

    if (D(pivot) < D(i)) pivot = i; // pivot index
    tr += D(i); // trace
  }

tl *= tr; // scaling prec by the trace for relative error

int allocSize = 10; int LSize = allocSize;
real[int,int] AL(2*Nv,2*Nv); AL = 0.; matrix L = AL; L.resize(2*Nv, LSize);

while ((k < stop) && (tl < tr)){ // main loop
  if (LSize - 1 <= k) {
    LSize += allocSize;
    L.resize(2*Nv, LSize); // resizing matrix
  }

  swtch = p(k);
  p(k) = p(pivot);
  p(pivot) = swtch; // changing p_pivot <-> p_k

  dk = sqrt(D(p(k)));
  L(p(k), k) = dk;

  if(p(k) < Nv){
    s = 1;
    xk = Th(p(k)).x;
    yk = Th(p(k)).y;
  } else {
    s = 2;
    xk = Th(p(k)-Nv).x;
    yk = Th(p(k)-Nv).y;
  }

  for (int i = k+1; i < 2*Nv; i++){
    if(p(i) < Nv){
      r = 1;
      xi = Th(p(i)).x;
      yi = Th(p(i)).y;
    } else {
      r = 2;
      xi = Th(p(i)-Nv).x;
      yi = Th(p(i)-Nv).y;
    }

    L(p(i), k) = K(xi,yi,xk,yk,r,s)/dk;
  }

  for (int i = k + 1; i < 2*Nv; i++)
    for (int j = 0; j < k; j++)
      L(p(i), k) -= L(p(i), j) * L(p(k), j) /  dk; //update L

  tr = 0.0;
  pivot = k + 1;

  for (int i = k+1; i < 2*Nv; ++i) {
    D(p(i)) -= L(p(i), k)^2; // update d
    if (D(p(pivot)) < D(p(i))) pivot = i; // update pivot
    tr += D(p(i)); // udate trace
  }

  k+=1;
}

L.resize(2*Nv, k); // resizing L

/* EIGENVALUE PROBLEM */

fespace VhK(Th, P1); // fe-space for domain map
fespace Vh(Th, [P1,P1]);

varf inpr ([u,v],[uu,vv]) = int2d(Th)(u*uu+v*vv); // inner product in L2

matrix M = inpr(Vh, Vh, solver=CG, eps=1e-20);

matrix C = L'*M; C = C*L; // low-rank matrix construction

int nev = C.n; // number of eigenvalues

real[int] ev(nev); // eigenvalues array

cout << "number of eig: " << C.n << endl;

border a(t=0, 2*pi){x=cos(t); y=sin(t); label=1;}
mesh ThL = buildmesh(a(C.n), nbvx = C.n);
fespace VhL(ThL, P1);
VhL[int] eVL(nev); 

func real[int] FOP (real[int] & u){ real[int] Au = C*u; return Au; }
int eig = EigenValue(C.n, A=FOP, mode=2, value=ev, nev = nev, vector=eVL, tol=tl); // eigenvalue problem solution

VhK[int] eV1(eig), eV2(eig), vgamma0(eig), vgamma1(eig);// eigenvectors array
real[int] aeV(L.n), gamma0(eig), gamma1(eig), gamma(eig), agamma(2); // temporary array

for (int i = 0; i < eig; i++){
  aeV =  L*eVL[i][]; // two eigenvectors as array

  eV1[i][] = aeV(0:aeV.n/2-1);
  eV2[i][] = aeV(aeV.n/2:aeV.n-1); // original eigenvectors

  vgamma0[i] = sqrt(eV1[i]^2 + eV2[i]^2);
  vgamma1[i] = sqrt(dx(eV1[i])*dx(eV1[i]) + dx(eV2[i])*dx(eV2[i]) + dy(eV1[i])*dy(eV1[i]) + dy(eV2[i])*dy(eV2[i]));

  gamma0[i] = vgamma0[i][].max;
  gamma1[i] = vgamma1[i][].max;

  agamma = [gamma0[i],  gamma1[i]];
  gamma[i] = 2*sqrt(3.)*sqrt(ev[i])*agamma.max;
}

/* SORTING */

int lng = eig;

while(lng--){
  bool swapped = false;
  VhK swap1, swap2;
  
  for(int i = 0; i < lng; i++){
    if(gamma[i] <= gamma[i + 1]){
      swap(gamma[i], gamma[i + 1]);
      swap(ev[i], ev[i + 1]);

      swap1 = eV1[i];
      eV1[i] = eV1[i+1];
      eV1[i+1] = swap1; 

      swap2 = eV2[i];
      eV2[i] = eV2[i+1];
      eV2[i+1] = swap2; 

      swapped = true;
    }
  }
  
  if(swapped == false) break;
}

/* SAVING */

ofstream fgamma("./storage/ev/gamma.txt");
ofstream fev("./storage/ev/ev.txt");
fev << eig << endl;

for (int i = 0; i < eig; i++){
  fgamma << gamma[i] << endl;

  ofstream feV1("./storage/ev/eV1/eV1" + i + ".txt");
  ofstream feV2("./storage/ev/eV2/eV2" + i + ".txt");

  feV1 << eV1[i][];
  feV2 << eV2[i][];
  fev << "  " << ev[i] << endl; 

  plot([eV1[i],eV2[i]], cmm="Eigen Vector "+i+" value ="+ev[i], wait=true, value=true, fill = true);
} 