load "msh3"
include "getARGV.idp"

/* MESH */

int n = getARGV("-n", 8); // setting triangulation number

real ly = 1; // y-length
real lx = 1.; // x-length

border G01(t=-lx, lx){x=t; y=-ly; label=1;} // lower boundary
border G02(t=-ly, ly){x=lx; y=t; label=2;} // right boundary
border G03(t=lx, -lx){x=t; y=ly; label=3;} // upper boundary
border G04(t=ly, -ly){x=-lx; y=t; label=4;} // lefr boundary

real rad = 0.5;

border G1(t=0, 2*pi){x=rad*cos(t); y=rad*sin(t); label=5;}

mesh Th0 = buildmesh(G01(lx*n)+G02(ly*n)+G03(lx*n)+G04(ly*n) + G1(-4*rad*n)); // body
mesh Th1 = buildmesh(G1(4*rad*n)); // inculsion 1

mesh Th = Th0 + Th1;

int Nv = Th.nv; // number of vertices

/* KERNEL FUNCTION */

func real B(real x, real y){
  real R = 5*abs((sqrt(x^2+y^2) - 0.5))+1.5;
  return (0.5*R^2*((R>=0)&&(R<1)) + 0.5*(-2*R^2 + 6*R-3)*((R>=1)&&(R<2)) +  0.5*((3-R)^2)*((R>=2)&&(R<3)))*4/3;
}

func real K (real xi, real yi, real xj, real yj, int r, int s){ // Kernel function
  real c = 1./30;
  real bi = B(xi,yi);
  real bj = B(xj,yj);

  real thetai = atan2(yi,xi);
  real thetaj = atan2(yj,xj);

  real f = 0.;

    if (r==1){
      if (s==1) f = 5*exp(-8.*((xi-xj)^2 + (yi-yj)^2))*cos(thetai)*cos(thetaj);
      else f = -exp(-5.*((2*xi-xj)^2 + (2*yi-yj)^2))*cos(thetai)*sin(thetaj);
    } else {
      if (s==1) f = -exp(-5.*((xi-2*xj)^2 + (yi-2*yj)^2))*sin(thetai)*cos(thetaj);
      else f = 5*exp(-8.*((xi-xj)^2 + (yi-yj)^2))*sin(thetai)*sin(thetaj);
    }

    f *= bi*bj*c;
  return f;
}

/* PIVOTED CHOLESKY DECOMPOSTION */

real tl = 1e-10;
int stop = 102;

int k = 0;
int swtch = 0;
int pivot = 0;

int r = 0;
int s = 0;

real xi = 0.;
real yi = 0.;
real xk = 0.;
real yk = 0.;

real dk = 0.;
real tr = 0.0;

int[int] p(2*Nv);
real[int] D(2*Nv);

  for (int i = 0; i < 2*Nv; i++) {
    if(i< Nv){
      r = 1;
      xi = Th(i).x;
      yi = Th(i).y;
    } else {
      r = 2;
      xi = Th(i-Nv).x;
      yi = Th(i-Nv).y;
    }

    p(i) = i; // indeces
    D(i) = K(xi,yi,xi,yi,r,r); // diagonal

    if (D(pivot) < D(i)) pivot = i; // pivot index
    tr += D(i); // trace
  }

tl *= tr; // scaling prec by the trace for relative error

int allocSize = 10; int LSize = allocSize;
real[int,int] AL(2*Nv,2*Nv); AL = 0.; matrix L = AL; L.resize(2*Nv, LSize);

while ((k < stop) && (tl < tr)){ // main loop
  if (LSize - 1 <= k) {
    LSize += allocSize;
    L.resize(2*Nv, LSize); // resizing matrix
  }

  swtch = p(k);
  p(k) = p(pivot);
  p(pivot) = swtch; // changing p_pivot <-> p_k

  dk = sqrt(D(p(k)));
  L(p(k), k) = dk;

  if(p(k) < Nv){
    s = 1;
    xk = Th(p(k)).x;
    yk = Th(p(k)).y;
  } else {
    s = 2;
    xk = Th(p(k)-Nv).x;
    yk = Th(p(k)-Nv).y;
  }

  for (int i = k+1; i < 2*Nv; i++){
    if(p(i) < Nv){
      r = 1;
      xi = Th(p(i)).x;
      yi = Th(p(i)).y;
    } else {
      r = 2;
      xi = Th(p(i)-Nv).x;
      yi = Th(p(i)-Nv).y;
    }

    L(p(i), k) = K(xi,yi,xk,yk,r,s)/dk;
  }

  for (int i = k + 1; i < 2*Nv; i++)
    for (int j = 0; j < k; j++)
      L(p(i), k) -= L(p(i), j) * L(p(k), j) /  dk; //update L

  tr = 0.0;
  pivot = k + 1;

  for (int i = k+1; i < 2*Nv; ++i) {
    D(p(i)) -= L(p(i), k)^2; // update d
    if (D(p(pivot)) < D(p(i))) pivot = i; // update pivot
    tr += D(p(i)); // udate trace
  }

  k+=1;
}

L.resize(2*Nv, k); // resizing L

/* EIGENVALUE PROBLEM */
fespace VhK(Th, P1); // fe-space for domain map
fespace Vh(Th, [P1,P1]);

varf inpr ([u,v],[uu,vv]) = int2d(Th)(u*uu+v*vv); // inner product in L2

matrix M = inpr(Vh, Vh, solver=CG, eps=1e-20);

matrix C = L'*M; C = C*L; // low-rank matrix construction

int nev = C.n; // number of eigenvalues

real[int] ev(nev); // eigenvalues array

border a(t=0, 2*pi){x=cos(t); y=sin(t); label=1;}
mesh ThL = buildmesh(a(C.n), nbvx = C.n);
fespace VhL(ThL, P1);
VhL[int] eVL(nev); 

func real[int] FOP (real[int] & u){ real[int] Au = C*u; return Au; }
int eig = EigenValue(C.n, A=FOP, mode=2, value=ev, nev = nev, vector=eVL, tol=tl); // eigenvalue problem solution

VhK[int] eV1(eig), eV2(eig),  evV1(eig), evV2(eig), vgamma0(eig), vgamma1(eig); // eigenvectors array
real[int] aeV(L.n); // temporary array

real[int] gamma0(eig), gamma1(eig), gamma(eig);
real[int] agamma(3);

ofstream frate("./experiments/err/rate.txt");

for (int i = 0; i < eig; i++){
    aeV =  L*eVL[i][]; // two eigenvectors as array

    eV1[i][] = aeV(0:aeV.n/2-1);
    eV2[i][] = aeV(aeV.n/2:aeV.n-1); // original eigenvectors

    evV1[i] = ev[i]*eV1[i]; 
    evV2[i] = ev[i]*eV2[i];

    vgamma0[i] = sqrt(evV1[i]^2 + evV2[i]^2);
    vgamma1[i] = sqrt(dx(evV1[i])*dx(evV1[i]) + dx(evV2[i])*dx(evV2[i]) + dy(evV1[i])*dy(evV1[i]) + dy(evV2[i])*dy(evV2[i]));

    gamma0[i] = vgamma0[i][].max;
    gamma1[i] = vgamma1[i][].max;

    agamma = [gamma0[i],  gamma1[i]];
    gamma[i] = agamma.max;

    frate << gamma[i] << endl; 
}







