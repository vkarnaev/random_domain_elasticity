include "getARGV.idp"
load "iovtk"

int s = getARGV("-s", 1); // setting triangulation number

mesh Th0 = readmesh("./storage/meshes/det/mesh0.msh"); // body
mesh Th1 = readmesh("./storage/meshes/det/mesh1.msh"); // inculsion 
mesh Th = readmesh("./storage/meshes/det/mesh.msh"); // initialising mesh

func real Halton (int index, int base){ // Halton sequence function
  real f = 1.;
  real r = 0.;

  int i = index;
  int b = base;

  while(i > 0){
    f /= b;
    r += f*(i%b);
    i /=b;
  }

  r = sqrt(3)*(2.*r-1.);
  return r;
}

ifstream fev("./storage/ev/ev.txt"); // file with eigen values

real eig;
fev  >> eig; // number of eigen values

real[int] ev(eig);

fespace Vh(Th, P1);
Vh[int] eV1(eig), eV2(eig); // eigen vectors 
Vh KL1, KL2; // random deformation field

for (int i=0; i<eig; i++){
    ifstream feV1("./storage/ev/eV1/eV1" + i + ".txt"); 
    ifstream feV2("./storage/ev/eV2/eV2" + i + ".txt"); // files with eigen vector

    fev >> ev[i]; // array of eigen values
    feV1 >> eV1[i][];
    feV2 >> eV2[i][]; // arrays of eigen vector
   
    //plot([eV1[i],eV2[i]], cmm="Eigen Vector "+i+" value ="+ev[i], wait=true, value=true);

    KL1 = KL1 + Halton(s,i+2)*sqrt(ev[i])*eV1[i];
    KL2 = KL2 + Halton(s,i+2)*sqrt(ev[i])*eV2[i]; // KL computation
}

plot(Th,[KL1,KL2], wait=true, value=true);
//savevtk("./storage/paraview/KL_sample.vtu", Th, [KL1, KL2, 0], dataname="KL_sample");

Th0 = movemesh(Th0, [x+KL1, y+KL2]); // moving mesh
Th1 = movemesh(Th1, [x+KL1, y+KL2]); // moving mesh
Th = Th0 + Th1;

plot(Th, wait = true);
//savevtk("./storage/paraview/th_sample.vtu", Th, dataname="Th_sample");

savemesh(Th0, "./storage/meshes/rand/mesh0/mesh0_" + s + ".msh");
savemesh(Th1, "./storage/meshes/rand/mesh1/mesh1_" + s + ".msh");
savemesh(Th, "./storage/meshes/rand/mesh/mesh_" + s + ".msh");